import java.sql.*;
import java.util.ArrayList;

/**
 * Database access point for the program
 *
 * @author Zack Yourkavitch
 */
public class DBUpdater
{

  /**
   * Instance variables to help set up connection.
   * Information hidden
   */
  Hidden info = new Hidden();
  private final String user = info.getUser();
  private final String pass = info.getPass();
  private final String url = info.getUrl();
  protected Connection dbConnection;

  /**
   * registers the JDBC driver to activate JDBC
   * @return true when successful
   */
  public boolean activateJDBC()
  {
    try
    {
      DriverManager.registerDriver(new com.mysql.jdbc.Driver());
    }
    catch(SQLException e)
    {
      e.printStackTrace();
    }
    return true;
  }

  /**
   * Connects to the DB server using the instance
   * variables mentioned previously
   */
  public void connect()
  {
    try
    {
      dbConnection = DriverManager.getConnection(url, user, pass);
    }
    catch (SQLException e)
    {
      e.printStackTrace();
    }
  }

  /**
   * closes connection to the database
   */
  public void close()
  {
    try
    {
      dbConnection.close();
    }
    catch (SQLException e)
    {
      e.printStackTrace();
    }
  }

  /**
   * Adds user to the database
   * @param userID userID generated by UUID
   * @param username username input by user
   * @param email email input by user
   * @param password password input by user
   * @return true if successful
   * @throws SQLIntegrityConstraintViolationException when repeat email
   */
  public boolean addUserToDB(String userID, String username, String email, String password)
          throws SQLIntegrityConstraintViolationException
  {
    String addUser = "insert into user (userid, username, email, password) values (?, ?, ?, ?);";
    try
    {
      PreparedStatement preparedAddUser = dbConnection.prepareStatement(addUser);
      preparedAddUser.setString(1, userID);
      preparedAddUser.setString(2, username);
      preparedAddUser.setString(3, email);
      preparedAddUser.setString(4, password);
      int rowsAdded = preparedAddUser.executeUpdate();
      if (rowsAdded == 1)
      {
        System.out.println("Added");
        return true;
      }
      return false;
    }
    catch(SQLIntegrityConstraintViolationException s)
    {
      throw new SQLIntegrityConstraintViolationException();
    }
    catch (SQLException e)
    {
      e.printStackTrace();
      return false;
    }
  }

  /**
   * removes a user from the database
   * NOTE: When GUI implemented, this will not be callable unless
   * user is logged in to an existing userid
   * @param userid UUID generated user id
   * @return true if successfully removed
   */
  public boolean removeUserFromDB(String userid)
  {
    String removeUser = "delete from user where (userid = ?);";
    try
    {
      PreparedStatement preparedRemoveUser = dbConnection.prepareStatement(removeUser);
      preparedRemoveUser.setString(1, userid);
      int rowsRemoved = preparedRemoveUser.executeUpdate();
      if (rowsRemoved == 1)
      {
        System.out.println("Removed");
        return true;
      }
      return false;
    }
    catch (SQLException e)
    {
      throw new RuntimeException(e);
    }
  }

  /**
   * used to ensure login credentials, fetches a password given an email
   * @param email user inputted email
   * @return password for user
   * @throws DoesNotExistException if account does not exist for email
   * @throws SQLException to make prepareStatement happy
   */
  public String findPasswordFromEmail(String email) throws DoesNotExistException, SQLException {
    String foundPass;
    String selectUser = "select * from user where (email = ?);";
    PreparedStatement preparedSelectUser = dbConnection.prepareStatement(selectUser);
    preparedSelectUser.setString(1, email);
    ResultSet rs = preparedSelectUser.executeQuery();
    if(rs.next())
    {
      foundPass = rs.getString("password");
      return foundPass;
    }
    else
    {
      throw new DoesNotExistException("Email does not exist");
    }
  }

  /**
   * finds a user's ID given their email, used to
   * email user
   * @param userID ID of user to email
   * @return user's email address
   */
  public String findEmailFromID(String userID)
  {
    String foundID;
    String findID = "select * from user where userid = ?";
    try
    {
      PreparedStatement preparedFindID = dbConnection.prepareStatement(findID);
      preparedFindID.setString(1, userID);
      ResultSet user = preparedFindID.executeQuery();
      user.next();
      foundID = user.getString("email");
      return foundID;
    }
    catch(SQLException e)
    {
      throw new RuntimeException();
    }
  }

  /**
   * used when user deleting account to ensure it is
   * them deleting the account
   * @param userID currently logged in userID
   * @return user's password
   */
  public String findPasswordFromID(String userID)
  {
    String foundPass;
    String selectUser = "select * from user where (userid = ?);";
    try
    {
      PreparedStatement preparedSelectUser = dbConnection.prepareStatement(selectUser);
      preparedSelectUser.setString(1, userID);
      ResultSet rs = preparedSelectUser.executeQuery();
      rs.next();
      foundPass = rs.getString("password");
    }
    catch (SQLException e)
    {
      throw new RuntimeException(e);
    }
    return foundPass;
  }

  /**
   * Used to assign currentUserID a value in Application level
   * @param email user's email
   * @return user's ID
   */
  public String findUserID(String email)
  {
    String foundID;
    String selectUser = "select * from user where (email = ?);";
    try
    {
      PreparedStatement preparedSelectUser = dbConnection.prepareStatement(selectUser);
      preparedSelectUser.setString(1, email);
      ResultSet rs = preparedSelectUser.executeQuery();
      rs.next();
      foundID = rs.getString("userid");
    }
    catch (SQLException e)
    {
      throw new RuntimeException(e);
    }
    return foundID;
  }

  /**
   * Used to add a task to the database
   * @param taskID UUID generated ID
   * @param taskTitle title of the task
   * @param taskDesc brief description of task
   * @param deadline deadline for task, formatted (xx/xx)
   * @param priority priority, 1 for low 2 for high
   * @param taskUserID ID of user who made task
   * @return true if successfully added
   */
  public boolean addTaskToDB(String taskID, String taskTitle, String taskDesc, String deadline,
                             int priority, String taskUserID)
  {
    String addTask = "insert into task (taskid, tasktitle, taskdesc, deadline, priority, " +
            "taskuserid) values (?, ?, ?, ?, ?, ?)";
    try
    {
      PreparedStatement preparedAddTask = dbConnection.prepareStatement(addTask);
      preparedAddTask.setString(1, taskID);
      preparedAddTask.setString(2, taskTitle);
      preparedAddTask.setString(3, taskDesc);
      preparedAddTask.setString(4, deadline);
      preparedAddTask.setInt(5, priority);
      preparedAddTask.setString(6, taskUserID);
      int rowsAdded = preparedAddTask.executeUpdate();
      if (rowsAdded == 1) {
        System.out.println("Added");
        return true;
      }
      return false;
    }
    catch (SQLException e)
    {
      throw new RuntimeException(e);
    }
  }

  /**
   * removes a task from the DB
   * @param taskID ID of task to remove
   * @return true if successful
   */
  public boolean removeTaskFromDB(String taskID)
  {
    String removeTask = "delete from task where taskid = ?";
    try
    {
      PreparedStatement preparedRemoveTask = dbConnection.prepareStatement(removeTask);
      preparedRemoveTask.setString(1, taskID);
      int rowsRemoved = preparedRemoveTask.executeUpdate();
      if (rowsRemoved == 1) {
        System.out.println("removed");
        return true;
      }
    }
    catch(SQLException e)
    {
      e.printStackTrace();
      //Shouldn't occur
    }
    return false;
  }

  /**
   * removes a category from the DB
   * @param categoryID ID of category to remove
   * @return true if successful
   */
  public boolean removeCategoryFromDB(String categoryID)
  {
    String removeCategory = "delete from category where categoryid = ?";
    try
    {
      PreparedStatement preparedRemoveCategory = dbConnection.prepareStatement(removeCategory);
      preparedRemoveCategory.setString(1, categoryID);
      int rowsRemoved = preparedRemoveCategory.executeUpdate();
      if (rowsRemoved == 1) {
        System.out.println("removed");
        return true;
      }
    }
    catch(SQLException e)
    {
      e.printStackTrace();
      //Shouldn't occur
    }
    return false;
  }

  /**
   * Used to add a category to the DB
   * @param categoryID UUID generated ID
   * @param madeByUserID ID of user who made the category
   * @param categoryTitle title of category
   * @return true if successfully added
   */
  public boolean addCategoryToDB(String categoryID, String madeByUserID, String categoryTitle)
  {
    String addCategory = "insert into category (categoryid, madebyuserid, categorytitle) values (?, ?, ?);";
    try {
      PreparedStatement preparedAddCategory = dbConnection.prepareStatement(addCategory);
      preparedAddCategory.setString(1, categoryID);
      preparedAddCategory.setString(2, madeByUserID);
      preparedAddCategory.setString(3, categoryTitle);
      int rowsAdded = preparedAddCategory.executeUpdate();
      if (rowsAdded == 1) {
        System.out.println("Added");
        return true;
      }
      return false;
    }
    catch (SQLException e)
    {
      throw new RuntimeException(e);
    }
  }

  /**
   * finds category ID
   * @param categoryTitle name of category to locate
   * @param userID current user
   * @return the ID of category
   * @throws DoesNotExistException if no category with name
   */
  public String findCategoryID(String categoryTitle, String userID) throws DoesNotExistException
  {
    String foundCategoryID;
    String findCategory = "select * from category where (categorytitle = ? and madebyuserid = ?);";
    try
    {
      PreparedStatement preparedFindCategory = dbConnection.prepareStatement(findCategory);
      preparedFindCategory.setString(1, categoryTitle);
      preparedFindCategory.setString(2, userID);
      ResultSet rs = preparedFindCategory.executeQuery();
      rs.next();
      foundCategoryID = rs.getString("categoryid");
    }
    catch (SQLException e)
    {
      throw new DoesNotExistException("Category does not exist");
    }
    return foundCategoryID;
  }


  /**
   * adds a task to a certain category
   * @param taskID ID of given task
   * @param categoryID ID of given category
   * @return true if successful
   */
  public boolean addTaskToCategory(String taskID, String categoryID)
  {
    String updateTask = "update task set taskcategoryid = ? where taskid = ?";
    try
    {
      PreparedStatement prepareUpdateTask = dbConnection.prepareStatement(updateTask);
      prepareUpdateTask.setString(1, categoryID);
      prepareUpdateTask.setString(2, taskID);
      int rowsChanged = prepareUpdateTask.executeUpdate();
      if (rowsChanged == 1) {
        System.out.println("Task categorized");
        return true;
      }
    }
    catch (SQLException e)
    {
      throw new RuntimeException();
    }
    return false;
  }

  /**
   * removes a task from a category
   * @param taskID task to remove
   * @return true if successful
   */
  public boolean removeTaskCategory(String taskID)
  {
    String updateTask = "update task set taskcategoryid = NULL where taskid = ?";
    try
    {
      PreparedStatement prepareUpdateTask = dbConnection.prepareStatement(updateTask);
      prepareUpdateTask.setString(1, taskID);
      int rowsChanged = prepareUpdateTask.executeUpdate();
      if (rowsChanged == 1) {
        System.out.println("Task decategorized");
        return true;
      }
    }
    catch (SQLException e)
    {
      throw new RuntimeException();
    }
    return false;
  }

  /**
   * finds all tasks in a certain category
   * @param categoryID ID of that category
   * @return names of tasks in that category
   */
  public String[] findTasksInCategory(String categoryID)
  {
    String[] taskNames;
    String findTaskGroup = "select * from task where taskcategoryid = ?";
    String findSetSize = "select count(*) from task where taskcategoryid = ?";
    try
    {
      PreparedStatement preparedFindTaskGroup = dbConnection.prepareStatement(findTaskGroup);
      preparedFindTaskGroup.setString(1, categoryID);
      PreparedStatement preparedFindSize = dbConnection.prepareStatement(findSetSize);
      preparedFindSize.setString(1, categoryID);
      ResultSet tasks = preparedFindTaskGroup.executeQuery();
      ResultSet count = preparedFindSize.executeQuery();
      count.next();
      int size = count.getInt(1);
      taskNames = new String[size];
      for (int i = 0; i < size; i++) {
        tasks.next();
        taskNames[i] = tasks.getString("taskTitle");
      }
    }
    catch(SQLException e)
    {
      throw new RuntimeException();
    }
    return taskNames;
  }

  /**
   * finds all tasks for a given user
   * @param userID ID of user to find tasks for
   * @return list of user tasks
   */
  public ArrayList<String> findTasksForUser(String userID)
  {
    ArrayList<String> returnTasks = new ArrayList<>();
    String findTasks = "select * from task where taskuserid = ?";
    try
    {
      PreparedStatement preparedFindTasks = dbConnection.prepareStatement(findTasks);
      preparedFindTasks.setString(1, userID);
      ResultSet tasks = preparedFindTasks.executeQuery();
      while (tasks.next()) {
        String taskID = tasks.getString("taskid");
        String taskTitle = tasks.getString("tasktitle");
        String categoryID = tasks.getString("taskcategoryid");
        String category;
        if(!(categoryID == null))
        {
          category = findCategoryTitle(tasks.getString("taskcategoryid"));
        }
        else
        {
          categoryID = "null";
          category = "uncategorized";
        }
        String deadline = tasks.getString("deadline");
        String priority = tasks.getString("priority");
        returnTasks.add(formatData(taskID, taskTitle, category, categoryID, deadline));
      }
    }
    catch(SQLException e)
    {
      throw new RuntimeException();
    }
    return returnTasks;
  }

  /**
   * finds all tasks for user sorted by category
   * @param userID ID of user
   * @return list of sorted tasks
   */
  public ArrayList<String> findTasksForUserSortByCat(String userID)
  {
    ArrayList<String> returnTasks = new ArrayList<>();
    String findTasks = "select * from task where taskuserid = ? order by taskcategoryid";
    try
    {
      PreparedStatement preparedFindTasks = dbConnection.prepareStatement(findTasks);
      preparedFindTasks.setString(1, userID);
      ResultSet tasks = preparedFindTasks.executeQuery();
      while (tasks.next()) {
        String taskID = tasks.getString("taskid");
        String taskTitle = tasks.getString("tasktitle");
        String categoryID = tasks.getString("taskcategoryid");
        String category;
        if(!(categoryID == null))
        {
          category = findCategoryTitle(tasks.getString("taskcategoryid"));
        }
        else
        {
          categoryID = "null";
          category = "uncategorized";
        }
        String deadline = tasks.getString("deadline");
        String priority = tasks.getString("priority");
        returnTasks.add(formatData(taskID, taskTitle, category, categoryID, deadline));
      }
    }
    catch(SQLException e)
    {
      throw new RuntimeException();
    }
    return returnTasks;
  }

  /**
   * finds all tasks for user sorted by deadline
   * @param userID ID of user
   * @return list of sorted tasks
   */
  public ArrayList<String> findTasksForUserSortByDL(String userID)
  {
    ArrayList<String> returnTasks = new ArrayList<>();
    String findTasks = "select * from task where taskuserid = ? order by deadline";
    try
    {
      PreparedStatement preparedFindTasks = dbConnection.prepareStatement(findTasks);
      preparedFindTasks.setString(1, userID);
      ResultSet tasks = preparedFindTasks.executeQuery();
      while (tasks.next()) {
        String taskID = tasks.getString("taskid");
        String taskTitle = tasks.getString("tasktitle");
        String categoryID = tasks.getString("taskcategoryid");
        String category;
        if(!(categoryID == null))
        {
          category = findCategoryTitle(tasks.getString("taskcategoryid"));
        }
        else
        {
          categoryID = "null";
          category = "uncategorized";
        }
        String deadline = tasks.getString("deadline");
        String priority = tasks.getString("priority");
        returnTasks.add(formatData(taskID, taskTitle, category, categoryID, deadline));
      }
    }
    catch(SQLException e)
    {
      throw new RuntimeException();
    }
    return returnTasks;
  }

  /**
   * finds title of category given ID, mainly used to get text
   * to remove from dropdown
   * @param categoryID ID of category
   * @return title of category
   */
  public String findCategoryTitle(String categoryID)
  {
    String returnTitle;
    String findTitle = "select * from category where categoryid = ?";
    try
    {
      PreparedStatement preparedFindTitle = dbConnection.prepareStatement(findTitle);
      preparedFindTitle.setString(1, categoryID);
      ResultSet category = preparedFindTitle.executeQuery();
      category.next();
      returnTitle = category.getString("categorytitle");
    }
    catch(SQLException e)
    {
      throw new RuntimeException();
    }
    return returnTitle;
  }

  /**
   * formats the data that will be added to text area
   * @param taskID ID of task
   * @param taskTitle title of task
   * @param categoryTitle category of task (if exists)
   * @param categoryID ID of category (if exists)
   * @param deadline deadline of task
   * @return formatted String
   */
  public String formatData(String taskID, String taskTitle, String categoryTitle, String categoryID, String deadline)
  {
    while(taskTitle.length() < 20)
    {
      taskTitle = taskTitle + " ";
    }
    while(categoryTitle.length() < 20)
    {
      categoryTitle = categoryTitle + " ";
    }
    while(categoryID.length() < 10)
    {
      categoryID = categoryID + " ";
    }
    while(deadline.length() < 8)
    {
      deadline = deadline + " ";
    }
    return "TaskID: " + taskID + "| " + taskTitle + "| " + categoryTitle + "CategoryID: " + categoryID + "| " + "Due: " + deadline;
  }

  /**
   * lists all categories for current user
   * @param userID ID of current user
   * @return list of categories
   */
  public ArrayList<String> findCategoriesForUser(String userID)
  {
    ArrayList<String> categoryTitles = new ArrayList<>();
    String findCats = "select * from category where madebyuserid = ?";
    try
    {
      PreparedStatement preparedFindCats = dbConnection.prepareStatement(findCats);
      preparedFindCats.setString(1, userID);
      ResultSet cats = preparedFindCats.executeQuery();
      while (cats.next()) {
        categoryTitles.add(cats.getString("categorytitle"));
      }
    }
    catch(SQLException e)
    {
      throw new RuntimeException();
    }
    return categoryTitles;
  }

}

/**
 * Exception used within DB when a row does not exist
 *
 * @author Zack Yourkavitch
 */
class DoesNotExistException extends Exception
{
  String message;
  DoesNotExistException(String message)
  {
    this.message = message;
  }

  public String getMessage()
  {
    return message;
  }
}
